[{"title":"双栈算术表达式求值算法","date":"2017-10-30T00:42:07.000Z","path":"2017/10/30/evaluate/index/","text":"Dijkatra的双栈算术表达式求值算法 算法第四版(java版) P 80-81 123456789101112131415161718192021222324252627282930import java.util.Stack;public class Evaluate &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; ops = new Stack&lt;String&gt;(); Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;(); while (!StdIn.isEmpty()) &#123; String s = StdIn.readString(); if (s.equals(\"(\")) ; else if (s.equals(\"+\")) ops.push(s); else if (s.equals('-')) ops.push(s); else if (s.equals(\"*\")) ops.push(s); else if (s.equals(\"/\")) ops.push(s); else if (s.equals(\"sqrt\")) ops.push(s); else if (s.equals(\")\")) &#123; // pop stack String op = ops.pop(); Double val = vals.pop(); if (op.equals(\"+\")) val = vals.pop() + val; else if (op.equals(\"-\")) val = vals.pop() - val; else if (op.equals(\"*\")) val = vals.pop() * val; else if (op.equals(\"/\")) val = vals.pop() / val; else if (op.equals(\"sqrt\")) val = Math.sqrt(val); vals.push(val); &#125; else vals.push(Double.parseDouble(s)); &#125; System.out.println(vals.pop()); &#125;&#125; evaluate_data.txt 1( ( 1 + sqrt ( 5.0 ) ) / 2.0 ) 运算结果 123$ javac Evaluate.java$ java Evaluate &lt; evaluate_data.txt$ 1.618033988749895 分析 将操作数压入操作数栈 将运算符压入运算符栈 忽略左括号 在遇到有括号时，弹出一个运算符，以及所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈 例如： ( 1 + ( 2 + 3 ) ( 4 5 ) ) ( 1 + ( 5 ) ( 4 5 ) ) ( 1 + ( 5 ) * ( 20 ) ) ( 1 + 100 ) 101 图解 evaluate图解 源代码github download","tags":[{"name":"算法(第四版)","slug":"算法-第四版","permalink":"http://blog.hzhihua.top/tags/算法-第四版/"},{"name":"第一章","slug":"第一章","permalink":"http://blog.hzhihua.top/tags/第一章/"}]},{"title":"二分查找法","date":"2017-10-28T04:59:23.000Z","path":"2017/10/28/binarySearch/index/","text":"二分查找法假设你要在电话簿中查找一个以K开头的名字（现在谁还用电话簿！），可以从头开始翻页，一直翻到以K开头的部分。但是你应该不会这样做，而是直接从中间开始查找，因为你知道以K开头的名字在电话簿中间。 现在假设你要登录Facebook。当你登录的时候，Facebook肯定会核实一下你的账号是否在Facebook上注册过。假设你的用户名为Karlmageddon，Facebook可以从以A开头的部分开始查找，但是更符合逻辑的方法是从中间找起。 这是一个查找问题，在以上所描述的所有情况下，都可以使用同一种算法来解决问题，这中算法就是二分查找 。 什么是二分查找法在一个 有序数组 (必须是有序数组)中查找某一个特定元素的算法。搜索过程从中间开始，如果中间元素正好是要搜索的元素，则搜索过程结束。如果中间元素大于要搜索的元素，则在小于中间元素的另一半中查找。若中间元素小于要搜索的元素，则在大于中间元素的另一半中查找。 图解 二分查找图解 代码实现12345678910111213141516171819202122232425262728public class BinarySearch&#123; /** * 查找指定元素是否存在有序数组中 * @param int key 要查找的元素 * @param array a 有序数组 * @return 查找成功返回指定索引的位置，失败返回 -1 */ public static int search(int key, int[] a) &#123; // 数组必须是有序的 int lo = 0; int hi = a.length - 1; // 获取数组的最大索引 int mid = 0; // 中间元素索引 while (lo &lt;= hi) &#123; mid = lo + (hi - lo) / 2; if (a[mid] == key) return mid; if (a[mid] &gt; key) hi = mid - 1; else if (a[mid] &lt; key) lo = mid + 1; &#125; return -1; &#125;&#125; 增长数量级分类 此算法属于 对数级别(logN) log底数为2 说明 位于算法(第四版)28页","tags":[{"name":"算法(第四版)","slug":"算法-第四版","permalink":"http://blog.hzhihua.top/tags/算法-第四版/"},{"name":"第一章","slug":"第一章","permalink":"http://blog.hzhihua.top/tags/第一章/"}]}]